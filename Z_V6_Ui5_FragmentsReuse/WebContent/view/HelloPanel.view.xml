<mvc:View
   controllerName="sap.ui.Z.controller.HelloPanel"
   xmlns="sap.m"
   xmlns:mvc="sap.ui.core.mvc">
   <Panel
      headerText="{i18n>helloPanelTitle}"
      width="auto" >
      <content>
      	<Button
         id="helloDialogButton"
         icon="sap-icon://world"
         text="{i18n>openDialogButtonText}"
         press=".onOpenDialog"
         class="sapUiSmallMarginEnd"/>
         <Button
            text="{i18n>buttonText}"
            press=".onShowH"
            class="myAppDemoWT myCustomButton"/>
         <Input
            value="{/recipient/name}"
            valueLiveUpdate="true"
            width="60%"/>
         <FormattedText
            htmlText="Salut {/recipient/name}"
            class="sapUiSmallMargin sapThemeHighlight-asColor myCustomText"/>
      </content>
   </Panel>
</mvc:View>

<!-- 
Dialogs and Fragments

Fragments are light-weight UI parts (UI subtrees) which can be reused but do not have any controller. 
This means, whenever you want to define a certain part of your UI to be reusable across multiple views, 
or when you want to exchange some parts of a view against one another under certain circumstances 
(different user roles, edit mode vs read-only mode), a fragment is a good candidate, especially where 
no additional controller logic is required.

A fragment can consist of 1 to n controls. At runtime, fragments placed in a view behave similar 
to "normal" view content, which means controls inside the fragment will just be included into the 
view’s DOM when rendered. There are of course controls that are not designed to become part of a view, 
for example, dialogs.

But even for these controls, fragments can be particularly useful, as you will see in a minute.

We will now add a dialog to our app. Dialogs are special, because they open on top of the regular app 
content and thus do not belong to a specific view. That means the dialog must be instantiated somewhere 
in the controller code, but since we want to stick with the declarative approach and create reusable 
artifacts to be as flexible as possible, and because dialogs cannot be specified as views, we will create 
an XML fragment containing the dialog. A dialog, after all, can be used in more than only one view of your app.

We add a new button to the view to open the dialog. It simply calls an event handler function in the controller of the panel’s content view. We will need the new id="helloDialogButton" in Step 29: Integration Test with OPA.

It is a good practice to set a unique ID like helloWorldButton to key controls of your app so that can be 
identified easily. If the attribute `id` is not specified, the OpenUI5 runtime generates unique but changing 
ID like `__button23` for the control. Inspect the DOM elements of your app in the browser to see the difference.



 -->

